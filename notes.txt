Symbol Table design notes:

i32 x;
u8 y;
{
  struct MyStruct {}
  MyStruct z;
}


Scopes      : [ 0, 1 ]
Types       : [ (i32, 0), (u8, 0), (MyStruct, 1) ]
Variables   : [ (x, 0), (y, 0), (z, 1) ]


Lookup type from string "MyStruct":
- I am in scope 1
- Iterate through Types and match the type name

Lookup variable from string "z":
- I am in scope 1
- Iterate through variables and match for name

Both lookups are Theta(n)
Both insertions are O(1)


==
Scopes : [ {T: i32, u8 ; V: x, y}, {T: MyStruct ; V: z} ]

Lookup type from string "MyStruct":
- I am in scope 1
- Go to scope one {T: MyStruct ; V: z}
- Iterate through types and compare, if it doesn't exist, go to the parent

Lookup variable from string "z":
- I am in scope 1
- Go to scope one {T: MyStruct ; V: z}
- Iterate through declared variables in scope 1 and match by name

Common case is faster during lookup O(n)
Insertion still O(1)


Grammar notes:
- Statements do not exist on rhs

Scoping Rules:
- Functions
  - Parameters and block all in the same scope
- Blocks
  - Scoped in everything except when attached to function
- For/While loops
  - Parameter scopes with inner block scope
- Struct
  - field scopes
  - Literal arguments scope


- Symbol Table Snapshot Testing
- Should I remove all optionals and instead use U0_TYPE? This way type inferring will have a type, and it will actually be associated to a type.
  - I should be associating NullLiteralNode type to U0_TYPE


// TODO
- go through codebase and find when I should/shouldn't be using std::move

- Throwing Exceptions in parser should make sure to close the current scope


- Symbol table lookup of raw types instead of Type objects made on the stack
  - Ex:
    - std::shared_ptr<Type> lookup_named_type(const std::string& name, size_t current_scope_id) const;
    - std::shared_ptr<Type> lookup_function_type(std::vector<std::shared_ptr<Type>> param_types, std::shared_ptr<Type> ret_type, size_t current_scope_id) const;

- Decide on how struct/field mutability should work and what it should look like syntactically

Type checker:
- Identifiers are expressions, thus they have a resolved type
- Variable declarations have a type as a part of the Node, thus the identifier's resolved type will equal that one.
  - Note that we can set that resolved type to that identifier, but what is stored in the symbol table is a 'Variable', thus we have to mark that one as well, so that when we reach an identifier we can access the resolved type from the symtab


-- ADD BYTE SIZE TO ALL TYPES



IR REPRESENTATION GOAL:

Printing:
```
void main() {
  int a;
  a = 2 + a;
  print a;

  string b = "hi";
  print b;

  bool c = true;
  print c;
}

main:
  BeginFunc 20;
  _t0 = 2;
  _t1 = _t0 + a;
  a = _t1;
  PushParam a;
  LCall _PrintInt;
  PopParams 4;
  b = "hi";
  PushParam b;
  LCall _PrintString;
  PopParams 4;
  c = 1;
  PushParam c;
  LCall _PrintInt;
  PopParams 4
  Return 0;
  EndFunc;
  Exit;
```


Arithmetic:
```
void main() {
  int b;
  int a;
  b = 3;
  a = 12;
  a = (b + 2)-(a * 3)/6;
}

main:
  BeginFunc 44;
  _t0 = 3;
  b = _t0;
  _t1 = 12;
  a = _t1;
  _t2 = 2;
  _t3 = b + _t2;
  _t4 = 3;
  _t5 = a * _t4;
  _t6 = 6;
  _t7 = _t5 / _t6;
  _t8 = _t3 - _t7;
  a = _t8
  Return 0;
  EndFunc;
  Exit;
```


No main:
```
int a;
a = 3;

main:
  _t0 = 3;
  a = _t0;
  Exit;
```


Arr/Ptr access:
```
void foo(int* arr) {
  arr[1] = arr[0] * 2;
}

_foo:
  BeginFunc 44;
  _t0 = 1;
  _t1 = 4;
  _t2 = _t1 * _t0;
  _t3 = arr + _t2;
  _t4 = 0;
  _t5 = 4;
  _t6 = _t5 * _t4;
  _t7 = arr + _t6;
  _t8 = *(_t7);
  _t9 = 2;
  _t10 = _t8 * _t9;
  *(_t3) = _t10;
  Return 0;
  EndFunc;
```

Function Calls:
```
int foo(int a, int b) {
  return a + b;
}

void main() {
  int c;
  int d;
  foo(c, d);
}

_foo:
  BeginFunc 4;
  _t0 = a + b;
  Return _t0;
  EndFunc;
main:
  BeginFunc 12;
  PushParam d;
  PushParam c;
  _t1 = LCall _foo;
  PopParams 8;
  Return 0;
  EndFunc;
  Exit;
```

If-Statements:
```
void main() {
  int a;
  a = 23;
  if (a == 23) {
    a = 10;
  } else {
    a = 19;
  }
}

main:
  BeginFunc 24;
  _t0 = 23;
  a = _t0;
  _t1 = 23;
  _t2 = a == _t1;
  IfZ _t2 Goto _L0;
  _t3 = 10;
  a = _t3;
  Goto _L1;
_L0:
  _t4 = 19;
  a = _t4;
_L1:
  Return 0;
  EndFunc;
  Exit;
```
