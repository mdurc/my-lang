func main() {
  mut a : i32;
  a = 2 + a;
  a = 3;
  print a;
  print "\n";

  b : string = "hi";
  print b;
  print "\n";
}

/*
EXPECTED ASSEMBLY OUTPUT:
  section .data
LC0:
  db 10, 0
LC1:
  db "hi", 0

  global _start
  section .text

_start:
  call main
  mov rdi, rax
  call exit

main:
  ; function prologue
  push rbp ; save rbp context
  mov rbp, rsp ; update rbp to start at this functions base stack offset
  sub rsp, 16 ; space for locals (a:4 bytes, b:8 bytes)

  ; Callee-saved regs based on what is used in the function
  push r12
  push r13
  push r14
  push r15

  ; mut a : i32;
  mov DWORD[rbp - 4], 0 ; a = 0 : default initialization

  ; a = 2 + a;
  mov r10, 2 ; _t0 = 2
  mov r11d, r10d ; _t1 = _t0
  add r11d, DWORD[rbp - 4] ; _t1 += a
  mov DWORD[rbp - 4], r11d ; a = _t1

  ; a = 3
  mov r12, 3 ; _t2 = 3
  mov DWORD[rbp - 4], r12d ; a = _t2

  ; PushArg a (we don't push to stack, we just use argument registers)
  mov edi, DWORD[rbp - 4] ; movsxd for signed DWORD extend, else movzx/movsx
  call print_int
  ; no emit from PopArgs because we did not allocate anything

  ; print newline
  mov r13, LC0 ; _t3 = &"\n"
  mov rdi, r13 ; PushArg _t3
  call print_string

  ; print hi
  mov r14, LC1 ; _t4 = &"hi"
  mov QWORD[rbp - 12], r14 ; b = _t4
  mov rdi, QWORD[rbp - 12] ; PushArg b
  call print_string

  ; print newline
  mov r15, LC0 ; _t5 = &"\n"
  mov rdi, r15 ; PushArg _t5
  call print_string

  ; cleanup the function
  pop r15
  pop r14
  pop r13
  pop r12
  mov rsp, rbp ; restore stack
  pop rbp

  ; perform the return from main
  xor rax, rax ; void return
  ret
*/
